// Generated by CoffeeScript 1.6.3
/*

  Fwoom! A WebGL game by David Moench
*/


(function() {
  var DMOENCH;

  DMOENCH = DMOENCH || {};

  DMOENCH.Fwoom = new function() {
    var $container, BODYTYPE, Body, FPMS, Fwoom, HEIGHT, HERO_ENGINE_FORCE, Manifold, WIDTH, bbIntersects, bodies, camera, circleCircleCollide, collideWall, detectBodyCollisions, fwooms, handleCollisions, handleFwooms, handleKeyDown, handleKeyUp, handleKeys, hero, initObjects, keys_down, render, renderer, resolveBodyCollision, resolveBodyCollisions, scene, sign, time_last, updateBodies;
    WIDTH = 800;
    HEIGHT = 600;
    HERO_ENGINE_FORCE = 1000;
    BODYTYPE = {
      hero: 0,
      rock: 1,
      obstacle: 2
    };
    Object.freeze(BODYTYPE);
    FPMS = 60 / 1000;
    camera = null;
    scene = null;
    renderer = null;
    $container = $('#container');
    bodies = [];
    fwooms = [];
    hero = null;
    time_last = 0;
    keys_down = {};
    /*
      Initialize and start the game
    */

    this.init = function() {
      initObjects();
      document.onkeydown = handleKeyDown;
      document.onkeyup = handleKeyUp;
      render();
      return null;
    };
    /*
      Create WebGL renderer, camera, and a scene.
    */

    initObjects = function() {
      var aspect, far, hero_bump_map, hero_density, hero_geom, hero_mass, hero_mat, hero_mesh, hero_radius, hero_segs, max_vel, near, obst, obst_geom, obst_mass, obst_mat, obst_mesh, obst_radius, obst_segs, pointLight, rock, rock_density, rock_geom, rock_mass, rock_mat, rock_mesh, rock_radius, rock_segs, view_angle;
      renderer = new THREE.WebGLRenderer();
      scene = new THREE.Scene();
      view_angle = 90;
      aspect = WIDTH / HEIGHT;
      near = 0.1;
      far = 10000;
      camera = new THREE.PerspectiveCamera(view_angle, aspect, near, far);
      camera.position.z = 300;
      renderer.setSize(WIDTH, HEIGHT);
      $container.append(renderer.domElement);
      pointLight = new THREE.PointLight(0xFFFFFF);
      pointLight.position.set(100, -100, 200);
      hero_radius = 20;
      hero_segs = 64;
      hero_bump_map = THREE.ImageUtils.loadTexture("./img/glass-bump.jpeg");
      hero_mat = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        bumpMap: hero_bump_map
      });
      console.log(hero_mat);
      hero_geom = new THREE.CircleGeometry(hero_radius, hero_segs);
      hero_mesh = new THREE.Mesh(hero_geom, hero_mat);
      hero_mesh.position.set(0, 0, 0);
      max_vel = 400;
      hero_density = 0.002;
      hero_mass = hero_density * Math.PI * hero_radius * hero_radius;
      hero = new Body('hero', hero_mass, new THREE.Vector3(0), max_vel, hero_mesh);
      bodies[bodies.length] = hero;
      obst_radius = 40;
      obst_segs = 64;
      obst_mat = new THREE.MeshLambertMaterial({
        color: 0x0B61A4
      });
      obst_geom = new THREE.CircleGeometry(obst_radius, obst_segs);
      obst_mesh = new THREE.Mesh(obst_geom, obst_mat);
      obst_mesh.position.set(-100, 0, 0);
      obst_mass = 0;
      obst = new Body('obst', obst_mass, new THREE.Vector3(0), 0, obst_mesh);
      bodies[bodies.length] = obst;
      rock_radius = 20;
      rock_segs = 32;
      rock_mat = new THREE.MeshLambertMaterial({
        color: 0xFF4900
      });
      rock_geom = new THREE.CircleGeometry(rock_radius, rock_segs);
      rock_mesh = new THREE.Mesh(rock_geom, rock_mat);
      rock_mesh.position.set(100, 50, 0);
      rock_density = 0.002;
      rock_mass = rock_density * Math.PI * rock_radius * rock_radius;
      max_vel = 900;
      rock = new Body('rock', rock_mass, new THREE.Vector3(80, 40, 0), max_vel, rock_mesh);
      bodies[bodies.length] = rock;
      scene.add(pointLight);
      _.each(bodies, function(body) {
        return scene.add(body.mesh);
      });
      scene.add(camera);
      return null;
    };
    /*
      Move each body for the next frame according to its current velocity and
      the net force acting on it.
    */

    updateBodies = function(delta) {
      handleFwooms();
      _.each(bodies, function(body) {
        return body.update(delta);
      });
      return null;
    };
    /*
      Render Loop: Update scene, render it, and request next iteration
    */

    render = function() {
      var delta, time_now;
      time_now = new Date().getTime();
      if (time_last !== 0) {
        delta = (time_now - time_last) / 1000;
        handleKeys();
        updateBodies(delta);
        handleCollisions(delta);
      }
      time_last = time_now;
      renderer.render(scene, camera);
      requestAnimationFrame(render);
      return null;
    };
    /*
      Detect and resolve collisions between all bodies.
    */

    handleCollisions = function(delta) {
      var collisions;
      _.each(bodies, function(body) {
        return collideWall(body);
      });
      collisions = detectBodyCollisions(delta);
      resolveBodyCollisions(collisions);
      return null;
    };
    /*
      Detect collisions between bodies in the scene and generate a manifold
      object for each collision
    
      Returns a list of manifold objects
    */

    detectBodyCollisions = function(delta) {
      var a, b, collision, collisions, i, j, n, _i, _j, _ref;
      collisions = [];
      n = bodies.length;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        for (j = _j = _ref = i + 1; _ref <= n ? _j < n : _j > n; j = _ref <= n ? ++_j : --_j) {
          a = bodies[i];
          b = bodies[j];
          if (a !== b && bbIntersects(a, b)) {
            collision = circleCircleCollide(a, b);
            if (collision != null) {
              collisions[collisions.length] = collision;
            }
          }
        }
      }
      return collisions;
    };
    /*
      Determine if two circular bodies intersect and generate a manifold object
      for the collision.
    
      Returns:
        A Manifold object OR null if no collision.
    */

    circleCircleCollide = function(a, b) {
      var a_pos, b_pos, collision, d, n, r_sum;
      a_pos = a.mesh.position;
      b_pos = b.mesh.position;
      n = b_pos.clone();
      n.sub(a_pos);
      r_sum = a.mesh.geometry.radius + b.mesh.geometry.radius;
      d = n.length();
      if (d > r_sum) {
        return null;
      }
      collision = new Manifold(a, b);
      if (d !== 0) {
        collision.penetration = r_sum - d;
        n.normalize();
        collision.normal = n;
      } else {
        collision.penetration = a.mesh.geometry.radius;
        collision.normal = new THREE.Vector3(1, 0, 0);
      }
      return collision;
    };
    /*
      Determine if the bounding boxes of bodies A and B intersect.
    */

    bbIntersects = function(a, b) {
      var a_BB, b_BB, x_intersect, y_intersect;
      a.mesh.geometry.computeBoundingBox();
      b.mesh.geometry.computeBoundingBox();
      a_BB = a.mesh.geometry.boundingBox;
      b_BB = b.mesh.geometry.boundingBox;
      a_BB.min.add(a.mesh.position);
      a_BB.max.add(a.mesh.position);
      b_BB.min.add(b.mesh.position);
      b_BB.max.add(b.mesh.position);
      x_intersect = (a_BB.min.x <= b_BB.max.x) && (a_BB.max.x >= b_BB.min.x);
      y_intersect = (a_BB.min.y <= b_BB.max.y) && (a_BB.max.y >= b_BB.min.y);
      return x_intersect && y_intersect;
    };
    /*
      Resolve all collisions between bodies in the scene specified by the list of
      Manifold objects.
    */

    resolveBodyCollisions = function(collisions) {
      if (collisions.length === 0) {
        return;
      }
      _.each(collisions, function(collision) {
        return resolveBodyCollision(collision);
      });
      return null;
    };
    /*
      Resolve a single collision between 2 bodies, updating their velocities as
      appropriate.
    */

    resolveBodyCollision = function(collision) {
      var a, a_diff, a_inv_mass, a_mass_ratio, b, b_diff, b_inv_mass, b_mass_ratio, imp, imp_vect, mass_sum, rest, rv, rv_n;
      a = collision.a;
      b = collision.b;
      a_inv_mass = a.mass === 0 ? 0 : 1 / a.mass;
      b_inv_mass = b.mass === 0 ? 0 : 1 / b.mass;
      mass_sum = a.mass + b.mass;
      a_mass_ratio = a.mass / mass_sum;
      b_mass_ratio = 1.0 - a_mass_ratio;
      rv = new THREE.Vector3(0);
      rv.subVectors(b.vel, a.vel);
      rv_n = rv.dot(collision.normal);
      if (rv_n > 0) {
        return;
      }
      rest = 0.85;
      imp = -(1 + rest) * rv_n;
      imp /= a_inv_mass + b_inv_mass;
      imp_vect = collision.normal.clone();
      imp_vect.multiplyScalar(imp);
      a_diff = imp_vect.clone();
      a_diff.multiplyScalar(a_inv_mass);
      a.vel.sub(a_diff);
      b_diff = imp_vect.clone();
      b_diff.multiplyScalar(b_inv_mass);
      b.vel.add(b_diff);
      return null;
    };
    /*
      Check if BODY is colliding with a screen boundary, and if so reverse its
      velocity to bounce. Bouncing off the wall is perfectly elastic.
    */

    collideWall = function(body) {
      if (Math.abs(body.mesh.position.x) > WIDTH / 2 - body.mesh.geometry.radius) {
        body.vel.x *= -1;
      }
      if (Math.abs(body.mesh.position.y) > HEIGHT / 2 - body.mesh.geometry.radius) {
        body.vel.y *= -1;
      }
      return null;
    };
    /*
      Apply any existing fwoom forces to bodies in the scene
    */

    handleFwooms = function() {
      var time_now;
      if (fwooms.length === 0) {
        return;
      }
      _.each(fwooms, function(fwoom) {
        _.each(bodies, function(body) {
          var d, dist_vect, force_vect;
          if (body === hero) {
            return;
          }
          dist_vect = new THREE.Vector3(0);
          dist_vect.subVectors(body.mesh.position, fwoom.pos);
          d = dist_vect.length();
          if (d < fwoom.radius) {
            console.log("Fwooming body", body);
            console.log("dist: ", dist_vect);
            console.log("d: ", d);
            force_vect = dist_vect.clone();
            force_vect.normalize();
            force_vect.multiplyScalar(fwoom.power / d);
            body.force.add(force_vect);
            console.log("body.force", body.force);
          }
          return null;
        });
        return null;
      });
      time_now = new Date().getTime();
      if (time_now > fwooms[0].death_time) {
        fwooms.shift();
      }
      return null;
    };
    /*
      Calculate the sign of N. Return 1 if positive, -1 if negative
    */

    sign = function(n) {
      if (n >= 0) {
        return 1;
      } else {
        return -1;
      }
    };
    /*
      Record key press down in keys_down dictionary and handle one-off keys.
    */

    handleKeyDown = function(event) {
      keys_down[event.keyCode] = true;
      if (event.keyCode === 32) {
        return fwooms.push(new Fwoom(150, 400000, hero.mesh.position));
      }
    };
    /*
      Record key let up in keys_down dictionary
    */

    handleKeyUp = function(event) {
      return keys_down[event.keyCode] = false;
    };
    /*
      Handle user input based on state of keys_down dictionary. This applies to
      keys pressed over durations.
    */

    handleKeys = function() {
      if (keys_down[37]) {
        hero.force.setX(hero.force.x - HERO_ENGINE_FORCE);
      }
      if (keys_down[38]) {
        hero.force.setY(hero.force.y + HERO_ENGINE_FORCE);
      }
      if (keys_down[39]) {
        hero.force.setX(hero.force.x + HERO_ENGINE_FORCE);
      }
      if (keys_down[40]) {
        return hero.force.setY(hero.force.y - HERO_ENGINE_FORCE);
      }
    };
    /*
      Bodies are the physical entities in the scene.
    */

    Body = (function() {
      function Body(name, mass, vel, max_vel, mesh) {
        this.name = name;
        this.mass = mass || 0;
        this.vel = vel || new THREE.Vector3(0);
        this.mesh = mesh || null;
        this.max_vel = max_vel || 0;
        this.force = new THREE.Vector3(0);
      }

      Body.prototype.update = function(delta) {
        var dv, dxy;
        if (this.mass === 0) {
          return null;
        }
        dv = this.force.clone();
        dv.divideScalar(this.mass);
        dv.multiplyScalar(delta);
        this.vel.add(dv);
        dxy = this.vel.clone();
        dxy.multiplyScalar(delta);
        this.mesh.position.add(dxy);
        this.force.set(0, 0, 0);
        return null;
      };

      return Body;

    })();
    /*
      Manifolds are objects packaging up information about a collision that
      needs resolving.
    */

    Manifold = (function() {
      function Manifold(a, b) {
        this.a = a;
        this.b = b;
      }

      Manifold.prototype.penetration = 0.0;

      Manifold.prototype.normal = null;

      return Manifold;

    })();
    null;
    /*
      A force explosion that radially pushes all bodies in its range, except for
      the heros.
    */

    Fwoom = (function() {
      function Fwoom(radius, power, position) {
        this.radius = radius;
        this.power = power;
        this.pos = position;
        this.death_time = new Date().getTime() + 250;
      }

      return Fwoom;

    })();
    return null;
  };

  $(function() {
    return DMOENCH.Fwoom.init();
  });

  this.DMOENCH = DMOENCH;

}).call(this);
