// Generated by CoffeeScript 1.6.3
/*

  Fwoom! A WebGL game by David Moench
*/


(function() {
  var DMOENCH;

  DMOENCH = DMOENCH || {};

  DMOENCH.Fwoom = new function() {
    var $container, BODYTYPE, Body, FPMS, HEIGHT, HERO_ENGINE_FORCE, WIDTH, bodies, camera, collideWall, collisions, handleCollisions, handleKeyDown, handleKeyUp, handleKeys, hero, initObjects, keys_down, render, renderer, scene, sign, time_last, updateBodies;
    WIDTH = 800;
    HEIGHT = 600;
    HERO_ENGINE_FORCE = 400;
    BODYTYPE = {
      hero: 0,
      hunter: 1,
      rock: 2
    };
    Object.freeze(BODYTYPE);
    FPMS = 60 / 1000;
    camera = null;
    scene = null;
    renderer = null;
    $container = $('#container');
    bodies = [null];
    hero = null;
    collisions = null;
    time_last = 0;
    keys_down = {};
    /*
      Initialize and start the game
    */

    this.init = function() {
      initObjects();
      document.onkeydown = handleKeyDown;
      document.onkeyup = handleKeyUp;
      render();
      return null;
    };
    /*
      Create WebGL renderer, camera, and a scene.
    */

    initObjects = function() {
      var aspect, far, height, height_segs, hero_mat, hero_mesh, near, open_ended, pointLight, rad_segs, radius, view_angle;
      renderer = new THREE.WebGLRenderer();
      scene = new THREE.Scene();
      view_angle = 90;
      aspect = WIDTH / HEIGHT;
      near = 0.1;
      far = 10000;
      camera = new THREE.PerspectiveCamera(view_angle, aspect, near, far);
      camera.position.z = 300;
      renderer.setSize(WIDTH, HEIGHT);
      $container.append(renderer.domElement);
      pointLight = new THREE.PointLight(0xFFFFFF);
      pointLight.position.set(100, -250, 130);
      radius = 20;
      height = 0;
      rad_segs = 64;
      height_segs = 1;
      open_ended = false;
      hero_mat = new THREE.MeshLambertMaterial({
        color: 0xCC0000
      });
      hero_mesh = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, height, rad_segs, height_segs, open_ended), hero_mat);
      hero_mesh.position.set(100, 0, 0);
      hero_mesh.rotation.x = Math.PI / 2;
      hero = new Body('hero', 1.0, new THREE.Vector3(0), 300, hero_mesh);
      bodies[0] = hero;
      scene.add(pointLight);
      _.each(bodies, function(body) {
        return scene.add(body.mesh);
      });
      scene.add(camera);
      return null;
    };
    /*
      Move each body for the next frame according to its current velocity and
      the net force acting on it.
    */

    updateBodies = function(delta) {
      _.each(bodies, function(body) {
        return body.update(delta);
      });
      return null;
    };
    /*
      Render Loop: Update scene, render it, and request next iteration
    */

    render = function() {
      var delta, time_now;
      time_now = new Date().getTime();
      if (time_last !== 0) {
        delta = (time_now - time_last) / 1000;
        handleKeys();
        handleCollisions(delta);
        updateBodies(delta);
      }
      time_last = time_now;
      renderer.render(scene, camera);
      requestAnimationFrame(render);
      return null;
    };
    /*
      Detect and resolve collisions between all bodies.
    */

    handleCollisions = function(delta) {
      _.each(bodies, function(body) {
        return collideWall(body);
      });
      return null;
    };
    /*
      Check if BODY is colliding with a screen boundary, and if so reverse its
      velocity to bounce. Bouncing off the wall is perfectly elastic.
    */

    collideWall = function(body) {
      if (Math.abs(body.mesh.position.x) > WIDTH / 2 - body.mesh.geometry.radiusTop) {
        body.vel.x *= -1;
      }
      if (Math.abs(body.mesh.position.y) > HEIGHT / 2 - body.mesh.geometry.radiusTop) {
        body.vel.y *= -1;
      }
      return null;
    };
    /*
      Calculate the sign of N. Return 1 if positive, -1 if negative
    */

    sign = function(n) {
      if (n >= 0) {
        return 1;
      } else {
        return -1;
      }
    };
    /*
      Record key press down in keys_down dictionary
    */

    handleKeyDown = function(event) {
      return keys_down[event.keyCode] = true;
    };
    /*
      Record key let up in keys_down dictionary
    */

    handleKeyUp = function(event) {
      return keys_down[event.keyCode] = false;
    };
    /*
      Handle user input based on state of keys_down dictionary
    */

    handleKeys = function() {
      if (keys_down[37]) {
        hero.force.setX(hero.force.x - HERO_ENGINE_FORCE);
      }
      if (keys_down[38]) {
        hero.force.setY(hero.force.y + HERO_ENGINE_FORCE);
      }
      if (keys_down[39]) {
        hero.force.setX(hero.force.x + HERO_ENGINE_FORCE);
      }
      if (keys_down[40]) {
        return hero.force.setY(hero.force.y - HERO_ENGINE_FORCE);
      }
    };
    /*
      Bodies are the physical entities in the scene.
    */

    Body = (function() {
      function Body(name, mass, vel, max_vel, mesh) {
        this.name = name;
        this.mass = mass || 0;
        this.vel = vel || new THREE.Vector3(0);
        this.mesh = mesh || null;
        this.max_vel = max_vel || 0;
      }

      Body.prototype.force = new THREE.Vector3(0);

      Body.prototype.update = function(delta) {
        var dv, dxy;
        dv = this.force.clone();
        dv.divideScalar(this.mass);
        dv.multiplyScalar(delta);
        this.vel.add(dv);
        if (this.vel.length() > this.max_vel) {
          this.vel.sub(dv);
        }
        dxy = this.vel.clone();
        dxy.multiplyScalar(delta);
        this.mesh.position.add(dxy);
        this.force.set(0, 0, 0);
        return null;
      };

      return Body;

    })();
    return null;
  };

  $(function() {
    return DMOENCH.Fwoom.init();
  });

  this.DMOENCH = DMOENCH;

}).call(this);
